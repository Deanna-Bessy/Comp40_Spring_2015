COMP 40 HW 6
Graham Goudeau
Deanna Bessy

Design Checklist for full Universal Machine

11. Major components and their interfaces
    -Segmented memory interface
        We will keep track of the greatest unused segment identifier in a 
        counter variable. When the user frees a segment, that freed identifier 
        is placed in a stack to be reused if necessary later.  When the user 
        requests a new segment, the stack is used before the counter is 
        incremented.

        Major functions include:
        -Map segment: given a length, take a segment identifier from either the
            stack (if it is nonempty), or use the current counter value and then
            increment the counter.  The segment identifier and associated data
            are used as a key/value pair in a table.
        -Free segment: given a segment identifier, if it is one less than the 
            counter value, decrement the counter; otherwise add the value to the
            stack.  Then free the associated memory in the table.
        -Get word: given a segment identifier and an offset, return the
            indicated word from the segmented memory
        -Write word: given a segment identifier and an offset, write the given
            data to the location
    -On-disk format interface
        -Get op code: get the next word from the on-disk file, parse it for the
            op code, and return that code
    -UM interface
        The UM interface consists only of functions that implement each operator
    -Main
        Runs the UM
    
12. Architecture of the program

    Main interface:
        This interface handles opening the on-disk program files, and starting
            the UM.

    Segmented memory interface:
        This interface manages the UM's segmented memory, by keeping track of
            active segment identifiers and associated data.

    On-disk format interface:
        This module gets the words from the on-disk file, parses them for the
            op codes and indicated registers, and sends those to the UM
            execution phase.

    UM interface:
        This module does the actual instruction execution, and handles the
            registers by keeping them in an array. It reads and writes to the
            segmented memory as needed.

13. Test cases

    There will be test cases included for each UM operator.

    Segmented memory test cases:
    -Attempt to unmap a segment that has already been unmapped
    -Attempt to write/read a word that lies outside the end of a mapped segment
    -Does a large number of maps/unmaps
    -Map and unmap very large segments
    -Ensure that the um binary is called from the command line in a way that 
        abides by the contract
    -Test cases for all eight failure modes

Design Checklist for UM segmented memory

1. What is the abstract thing you are trying to represent?

    We are trying to emulate a segmented memory like what might be seen in
        hardware.  Segments have a 32-bit identifier, can be any length
        (specified by user), and consist of contiguous 32-bit words.

2. What functions will you offer, and what are their contracts?

    The memory is represented to the client as an opaque struct definition.  A
    pointer to the memory data must be passed to every memory-associated
    function.  This struct, memory_data, will hold the table with identifier/
    word data key/value pairs, the instruction pointer, the stack of segment
    identifiers that have been unmapped, and the counter indicating the 
    maximum unused segment identifier.

    typedef uint32_t segment_id;
    typedef uint32_t word;
    typedef struct memory_data *memory_data;

    - segment_id map_segment(size_t length, memory_data memory) - select a valid
        segment identifier, and create storage of the specified length.  Returns
        the now-valid id.
    - void free_segment(segment_id id, memory_data memory) - free the memory
        associated with the indicated segment identifier.
    - word get_word(segment_id id, size_t offset, memory_data memory) - returns
        the indicated word from the memory
    - void write_word(segment_id, size_t offset, word data, memory_data memory)
        given a segment identifier and an offset, write the given data to the 
        location
    - void free_memory(memory_data memory) - frees the memory associated with
        all data structures, including segments that the user left mapped at
        their program's termination

4. What representation will you use, and what invariants will it satisfy?

    We will use a table to store the mapped segment identifiers and associated
    storage as key/value pairs.  Segment identifiers that were mapped and 
    subsequently unmapped are stored in a stack.  The maximum unused identifier
    is stored as a counter value.  When a new segment is mapped, the next 
    identifier is chosen in the following way:
        -If the stack is nonempty, pop the next segment identifier from the
        stack and use that value.
        -Otherwise, use the current value of the counter, and increment it.

    When a segment is unmapped, the associated data is freed and its identifier
    is pushed onto the stack.

    Invariants:
        - There will always be a bijection between segment identifiers and the
          actual segment data.
        - The stack is always emptied before the counter is incremented, and
          the counter is only incremented if the stack is empty.
        - The segment identifiers are always strictly less than 2^32.
